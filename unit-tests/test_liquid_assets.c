#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <cmocka.h>

#include "sha-256.h"
#include "liquid/liquid_hash_wrappers.h"
#include "liquid/liquid_assets.h"

extern bool sha256_midstate_reversed(const cx_sha256_t* sha256_context, uint8_t out[32]);
extern bool generate_asset_entropy(const uint8_t contract_hash[static SHA256_LEN],
                                   const uint8_t prevout_txid[static SHA256_LEN],
                                   uint32_t prevout_index,
                                   uint8_t entropy[static SHA256_LEN]);
extern bool compute_asset_tag_from_entropy(const uint8_t entropy[SHA256_LEN],
                                           uint8_t asset_tag[static LIQUID_ASSET_TAG_LEN]);

extern const asset_definition_t liquid_assets[];
extern const size_t n_liquid_assets;

typedef struct {
    uint8_t asset_tag[LIQUID_ASSET_TAG_LEN];
    uint8_t contract_hash[SHA256_LEN];
    uint8_t prevout_txid[SHA256_LEN];
    uint32_t prevout_index;
    uint8_t entropy[SHA256_LEN];
} asset_test_data_t;

static const asset_test_data_t asset_test_data[] = {
    // tether.to USDt (Tether USD)
    {
        .asset_tag = {
            0xce, 0x09, 0x1c, 0x99, 0x8b, 0x83, 0xc7, 0x8b,
            0xb7, 0x1a, 0x63, 0x23, 0x13, 0xba, 0x37, 0x60,
            0xf1, 0x76, 0x3d, 0x9c, 0xfc, 0xff, 0xae, 0x02,
            0x25, 0x8f, 0xfa, 0x98, 0x65, 0xa3, 0x7b, 0xd2
        },
        .contract_hash = {
            0x3c, 0x7f, 0x0a, 0x53, 0xc2, 0xff, 0x5b, 0x99,
            0x59, 0x06, 0x20, 0xd7, 0xf6, 0x60, 0x4a, 0x7a,
            0x3a, 0x7b, 0xfb, 0xaa, 0xa6, 0xaa, 0x61, 0xf7,
            0xbf, 0xc7, 0x83, 0x3c, 0xa0, 0x3c, 0xde, 0x82
        },
        .prevout_txid = {
            0x95, 0x96, 0xd2, 0x59, 0x27, 0x0e, 0xf5, 0xba,
            0xc0, 0x02, 0x04, 0x35, 0xe6, 0xd8, 0x59, 0xae,
            0xa6, 0x33, 0x40, 0x94, 0x83, 0xba, 0x64, 0xe2,
            0x32, 0xb8, 0xba, 0x04, 0xce, 0x28, 0x86, 0x68
        },
        .prevout_index = 0,
        .entropy = {
            0x15, 0xe7, 0x13, 0x51, 0x64, 0x1d, 0x30, 0x01,
            0x98, 0x45, 0x31, 0x34, 0x42, 0x45, 0x28, 0x85,
            0xf6, 0x4b, 0xf5, 0x98, 0x5d, 0x36, 0x6f, 0x09,
            0xa2, 0x91, 0xe9, 0x49, 0xfa, 0x92, 0x96, 0x08
        }
    },
    // liquid.beer ASP (Atomic Swap Pint)
    {
        .asset_tag = {
            0x13, 0x31, 0x5b, 0x14, 0xd2, 0x40, 0xbd, 0xe1,
            0xe7, 0x97, 0xd8, 0x39, 0x6c, 0xd5, 0x8f, 0x1e,
            0x9f, 0xe9, 0xd0, 0xf4, 0x59, 0x29, 0x8a, 0x9c,
            0x35, 0xa8, 0xfa, 0x44, 0xba, 0x87, 0x46, 0x2e
        },
        .contract_hash = {
            0x0b, 0xba, 0x2b, 0x02, 0xe5, 0xa9, 0x39, 0xf3,
            0xcb, 0xdc, 0x87, 0xc7, 0x0b, 0xa0, 0x9b, 0x3d,
            0x64, 0xeb, 0x43, 0x4e, 0xef, 0x25, 0xb3, 0xf3,
            0x14, 0xaf, 0xcf, 0x0c, 0x0a, 0xd7, 0x07, 0x3f
        },
        .prevout_txid = {
            0xb7, 0xac, 0xa9, 0xbe, 0x7f, 0x31, 0x0a, 0xf0,
            0xd9, 0xcd, 0xe3, 0x49, 0xbc, 0x7c, 0x5b, 0x8d,
            0xd1, 0x38, 0xbb, 0xf0, 0x49, 0x9b, 0x28, 0xbf,
            0x48, 0x2f, 0xd7, 0xe6, 0xd3, 0xe9, 0x0b, 0x66
        },
        .prevout_index = 10,
        .entropy = {
            0xe1, 0xec, 0xa8, 0x4f, 0x9c, 0xa3, 0x1d, 0xdc,
            0xa3, 0x90, 0xd5, 0x68, 0x3d, 0xa4, 0x26, 0xf0,
            0x53, 0x0c, 0x6c, 0x84, 0x6c, 0x6e, 0x0a, 0x89,
            0x26, 0x31, 0xc5, 0xa5, 0x2f, 0xf9, 0x04, 0xe3
        }
    },
    // assets.btse.com BTSE (BTSE Token)
    {
        .asset_tag = {
            0xb0, 0x0b, 0x0f, 0xf0, 0xb1, 0x1e, 0xbd, 0x47,
            0xf7, 0xc6, 0xf5, 0x76, 0x14, 0xc0, 0x46, 0xdb,
            0xbd, 0x20, 0x4e, 0x84, 0xbf, 0x01, 0x17, 0x8b,
            0xaf, 0x2b, 0xe3, 0x71, 0x3a, 0x20, 0x6e, 0xb7
        },
        .contract_hash = {
            0x3b, 0xaa, 0x39, 0x51, 0x51, 0x19, 0x49, 0x1d,
            0xc0, 0x5f, 0xc8, 0x0b, 0xe3, 0x74, 0x6e, 0xff,
            0x5c, 0x92, 0x1e, 0xde, 0xfb, 0xee, 0x4b, 0xab,
            0x64, 0xf4, 0xa7, 0x89, 0x73, 0x71, 0x49, 0xf8
        },
        .prevout_txid = {
            0x8d, 0xec, 0xec, 0xf2, 0xb3, 0xcf, 0xa6, 0x1e,
            0xeb, 0xb2, 0xac, 0x89, 0xaf, 0xb0, 0xd2, 0x25,
            0xb9, 0x91, 0x73, 0x47, 0x02, 0xb1, 0x3c, 0xbb,
            0x1e, 0xe7, 0x6e, 0x86, 0xb9, 0x57, 0xb7, 0x5b
        },
        .prevout_index = 1,
        .entropy = {
            0x7b, 0x64, 0x6f, 0x55, 0x2a, 0x94, 0xbf, 0x0c,
            0xb9, 0xd2, 0x67, 0x35, 0x25, 0x12, 0xe1, 0xb7,
            0x0b, 0x30, 0xef, 0xaa, 0x6a, 0xe0, 0x9e, 0xe0,
            0x7e, 0x21, 0x5d, 0x53, 0x55, 0xb9, 0x38, 0xce
        }
    },
};

static void test_liquid_get_asset_info(void **state) {
    (void) state;

    // Scan through all asset values in table
    asset_info_t asset;
    const asset_info_t *result = NULL;
    for(int i = 0; i < n_liquid_assets; ++i) {
        asset = liquid_assets[i].info;
        result = liquid_get_asset_info(liquid_assets[i].tag);
        assert_non_null(result);
        assert_ptr_not_equal(result, &asset);
        assert_string_equal(result->ticker, asset.ticker);
        assert_true(result->decimals == asset.decimals);
    }

    // Try to find an asset by passing random asset tag
    // SHA-256 is used as PRNG function
    uint8_t tag[SIZE_OF_SHA_256_HASH] = { 0 };
    assert_null( liquid_get_asset_info(tag) );
    memset(tag, 0xFF, sizeof(tag));
    for (int i = 0; i < 100000; ++i) {
        assert_null( liquid_get_asset_info(tag) );
        calc_sha_256(tag, tag, sizeof(tag));
    }

    // Try passing NULL as asset tag
    const uint8_t *null_tag = NULL;
    assert_null( liquid_get_asset_info(null_tag) );
}

static void test_sha256_midstate_reversed(void **state) {
    (void) state;
    static const uint8_t data[] = {
        0x9d, 0xd0, 0x1b, 0x56, 0xb1, 0x56, 0x45, 0x14,
        0x3e, 0xad, 0x15, 0x8d, 0xec, 0x19, 0xf8, 0xce,
        0xa9, 0x0b, 0xd0, 0xa9, 0xb2, 0xf8, 0x1d, 0x21,
        0xff, 0xa3, 0xa4, 0xc6, 0x44, 0x81, 0xd4, 0x1c,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    static const uint8_t ref_midstate[] = { // reversed
        0x03, 0x2e, 0x03, 0x7f, 0x7f, 0x33, 0xed, 0x14,
        0xb4, 0x05, 0x06, 0x2a, 0x91, 0x12, 0xf7, 0xf2,
        0x03, 0xf5, 0xb0, 0xf0, 0x1d, 0x7c, 0x4f, 0x4f,
        0xd3, 0xc7, 0x6c, 0x4e, 0xe5, 0xe0, 0xcf, 0x0b
    };

    cx_sha256_t sha_ctx;
    uint8_t midstate[SHA256_LEN] = { 0 };

    assert_true(hash_init_sha256(&sha_ctx));
    assert_true(hash_update(&sha_ctx.header, data, sizeof(data)));
    assert_true(sha256_midstate_reversed(&sha_ctx, midstate));
    assert_memory_equal (ref_midstate, midstate, sizeof(midstate));
}

void test_compute_asset_tag_from_entropy(void **state) {
    int n_vectors = sizeof(asset_test_data) / sizeof(asset_test_data[0]);
    const asset_test_data_t *p_vect = asset_test_data;
    uint8_t asset_tag[LIQUID_ASSET_TAG_LEN] = { 0 };
    bool res;

    for(int i = 0; i < n_vectors; ++i, p_vect++) {
        res = compute_asset_tag_from_entropy(p_vect->entropy, asset_tag);
        assert_true(res);
        assert_memory_equal(p_vect->asset_tag, asset_tag, sizeof(asset_tag));
    }
}

void test_generate_asset_entropy(void **state) {
    int n_vectors = sizeof(asset_test_data) / sizeof(asset_test_data[0]);
    const asset_test_data_t *p_vect = asset_test_data;
    uint8_t entropy[SHA256_LEN] = { 0 };

    for(int i = 0; i < n_vectors; ++i, p_vect++) {
        bool res = generate_asset_entropy(p_vect->contract_hash,
                                          p_vect->prevout_txid,
                                          p_vect->prevout_index,
                                          entropy);
        assert_true(res);
        assert_memory_equal(p_vect->entropy, entropy, sizeof(entropy));
    }
}

void test_liquid_compute_asset_tag(void **state) {
    int n_vectors = sizeof(asset_test_data) / sizeof(asset_test_data[0]);
    const asset_test_data_t *p_vect = asset_test_data;
    uint8_t asset_tag[LIQUID_ASSET_TAG_LEN] = { 0 };

    for(int i = 0; i < n_vectors; ++i, p_vect++) {
        bool res = liquid_compute_asset_tag(p_vect->contract_hash,
                                            p_vect->prevout_txid,
                                            p_vect->prevout_index,
                                            asset_tag);
        assert_true(res);
        assert_memory_equal(p_vect->asset_tag, asset_tag, sizeof(asset_tag));
    }
}

int main() {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test(test_liquid_get_asset_info),
        cmocka_unit_test(test_sha256_midstate_reversed),
        cmocka_unit_test(test_compute_asset_tag_from_entropy),
        cmocka_unit_test(test_generate_asset_entropy),
        cmocka_unit_test(test_liquid_compute_asset_tag)
    };

    return cmocka_run_group_tests(tests, NULL, NULL);
}
