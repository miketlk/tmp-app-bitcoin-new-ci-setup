/**
 * This file containing unit tests is intended to be included at the end of the
 * corresponding source file.
 *
 * Not to be included in normal way as a header!
 */

// #include "liquid_proofs_test_data.h"
#include "debug.h"

typedef struct {
    uint8_t asset_tag[LIQUID_ASSET_TAG_LEN];
    uint8_t contract_hash[SHA256_LEN];
    uint8_t prevout_txid[SHA256_LEN];
    uint32_t prevout_index;
    uint8_t entropy[SHA256_LEN];
    asset_class_t asset_class;
} asset_test_data_t;

static const asset_test_data_t asset_test_data[] = {
    // tether.to USDt (Tether USD)
    {.asset_tag = {0xce, 0x09, 0x1c, 0x99, 0x8b, 0x83, 0xc7, 0x8b, 0xb7, 0x1a, 0x63,
                   0x23, 0x13, 0xba, 0x37, 0x60, 0xf1, 0x76, 0x3d, 0x9c, 0xfc, 0xff,
                   0xae, 0x02, 0x25, 0x8f, 0xfa, 0x98, 0x65, 0xa3, 0x7b, 0xd2},
     .contract_hash = {0x3c, 0x7f, 0x0a, 0x53, 0xc2, 0xff, 0x5b, 0x99, 0x59, 0x06, 0x20,
                       0xd7, 0xf6, 0x60, 0x4a, 0x7a, 0x3a, 0x7b, 0xfb, 0xaa, 0xa6, 0xaa,
                       0x61, 0xf7, 0xbf, 0xc7, 0x83, 0x3c, 0xa0, 0x3c, 0xde, 0x82},
     .prevout_txid = {0x95, 0x96, 0xd2, 0x59, 0x27, 0x0e, 0xf5, 0xba, 0xc0, 0x02, 0x04,
                      0x35, 0xe6, 0xd8, 0x59, 0xae, 0xa6, 0x33, 0x40, 0x94, 0x83, 0xba,
                      0x64, 0xe2, 0x32, 0xb8, 0xba, 0x04, 0xce, 0x28, 0x86, 0x68},
     .prevout_index = 0,
     .entropy = {0x15, 0xe7, 0x13, 0x51, 0x64, 0x1d, 0x30, 0x01, 0x98, 0x45, 0x31,
                 0x34, 0x42, 0x45, 0x28, 0x85, 0xf6, 0x4b, 0xf5, 0x98, 0x5d, 0x36,
                 0x6f, 0x09, 0xa2, 0x91, 0xe9, 0x49, 0xfa, 0x92, 0x96, 0x08},
     .asset_class = ACLASS_ASSET},
    // liquid.beer ASP (Atomic Swap Pint)
    {.asset_tag = {0x13, 0x31, 0x5b, 0x14, 0xd2, 0x40, 0xbd, 0xe1, 0xe7, 0x97, 0xd8,
                   0x39, 0x6c, 0xd5, 0x8f, 0x1e, 0x9f, 0xe9, 0xd0, 0xf4, 0x59, 0x29,
                   0x8a, 0x9c, 0x35, 0xa8, 0xfa, 0x44, 0xba, 0x87, 0x46, 0x2e},
     .contract_hash = {0x0b, 0xba, 0x2b, 0x02, 0xe5, 0xa9, 0x39, 0xf3, 0xcb, 0xdc, 0x87,
                       0xc7, 0x0b, 0xa0, 0x9b, 0x3d, 0x64, 0xeb, 0x43, 0x4e, 0xef, 0x25,
                       0xb3, 0xf3, 0x14, 0xaf, 0xcf, 0x0c, 0x0a, 0xd7, 0x07, 0x3f},
     .prevout_txid = {0xb7, 0xac, 0xa9, 0xbe, 0x7f, 0x31, 0x0a, 0xf0, 0xd9, 0xcd, 0xe3,
                      0x49, 0xbc, 0x7c, 0x5b, 0x8d, 0xd1, 0x38, 0xbb, 0xf0, 0x49, 0x9b,
                      0x28, 0xbf, 0x48, 0x2f, 0xd7, 0xe6, 0xd3, 0xe9, 0x0b, 0x66},
     .prevout_index = 10,
     .entropy = {0xe1, 0xec, 0xa8, 0x4f, 0x9c, 0xa3, 0x1d, 0xdc, 0xa3, 0x90, 0xd5,
                 0x68, 0x3d, 0xa4, 0x26, 0xf0, 0x53, 0x0c, 0x6c, 0x84, 0x6c, 0x6e,
                 0x0a, 0x89, 0x26, 0x31, 0xc5, 0xa5, 0x2f, 0xf9, 0x04, 0xe3},
     .asset_class = ACLASS_ASSET},
    // assets.btse.com BTSE (BTSE Token)
    {.asset_tag = {0xb0, 0x0b, 0x0f, 0xf0, 0xb1, 0x1e, 0xbd, 0x47, 0xf7, 0xc6, 0xf5,
                   0x76, 0x14, 0xc0, 0x46, 0xdb, 0xbd, 0x20, 0x4e, 0x84, 0xbf, 0x01,
                   0x17, 0x8b, 0xaf, 0x2b, 0xe3, 0x71, 0x3a, 0x20, 0x6e, 0xb7},
     .contract_hash = {0x3b, 0xaa, 0x39, 0x51, 0x51, 0x19, 0x49, 0x1d, 0xc0, 0x5f, 0xc8,
                       0x0b, 0xe3, 0x74, 0x6e, 0xff, 0x5c, 0x92, 0x1e, 0xde, 0xfb, 0xee,
                       0x4b, 0xab, 0x64, 0xf4, 0xa7, 0x89, 0x73, 0x71, 0x49, 0xf8},
     .prevout_txid = {0x8d, 0xec, 0xec, 0xf2, 0xb3, 0xcf, 0xa6, 0x1e, 0xeb, 0xb2, 0xac,
                      0x89, 0xaf, 0xb0, 0xd2, 0x25, 0xb9, 0x91, 0x73, 0x47, 0x02, 0xb1,
                      0x3c, 0xbb, 0x1e, 0xe7, 0x6e, 0x86, 0xb9, 0x57, 0xb7, 0x5b},
     .prevout_index = 1,
     .entropy = {0x7b, 0x64, 0x6f, 0x55, 0x2a, 0x94, 0xbf, 0x0c, 0xb9, 0xd2, 0x67,
                 0x35, 0x25, 0x12, 0xe1, 0xb7, 0x0b, 0x30, 0xef, 0xaa, 0x6a, 0xe0,
                 0x9e, 0xe0, 0x7e, 0x21, 0x5d, 0x53, 0x55, 0xb9, 0x38, 0xce},
     .asset_class = ACLASS_ASSET},
};

static void test_sha256_midstate_reversed(test_ctx_t *test_ctx) {
    static const uint8_t data[] = {
        0x9d, 0xd0, 0x1b, 0x56, 0xb1, 0x56, 0x45, 0x14, 0x3e, 0xad, 0x15, 0x8d, 0xec,
        0x19, 0xf8, 0xce, 0xa9, 0x0b, 0xd0, 0xa9, 0xb2, 0xf8, 0x1d, 0x21, 0xff, 0xa3,
        0xa4, 0xc6, 0x44, 0x81, 0xd4, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    static const uint8_t ref_midstate[] = {// reversed
                                           0x03, 0x2e, 0x03, 0x7f, 0x7f, 0x33, 0xed, 0x14,
                                           0xb4, 0x05, 0x06, 0x2a, 0x91, 0x12, 0xf7, 0xf2,
                                           0x03, 0xf5, 0xb0, 0xf0, 0x1d, 0x7c, 0x4f, 0x4f,
                                           0xd3, 0xc7, 0x6c, 0x4e, 0xe5, 0xe0, 0xcf, 0x0b};

    cx_sha256_t sha_ctx;
    uint8_t midstate[SHA256_LEN] = {0};

    TEST_ASSERT(hash_init_sha256(&sha_ctx));
    TEST_ASSERT(hash_update(&sha_ctx.header, data, sizeof(data)));
    TEST_ASSERT(sha256_midstate_reversed(&sha_ctx, midstate));
    TEST_ASSERT_EQUAL_MEMORY(ref_midstate, midstate, sizeof(midstate));
}

void test_compute_asset_tag_from_entropy(test_ctx_t *test_ctx) {
    int n_vectors = sizeof(asset_test_data) / sizeof(asset_test_data[0]);
    const asset_test_data_t *p_vect = asset_test_data;
    uint8_t asset_tag[LIQUID_ASSET_TAG_LEN] = {0};
    bool res;

    for (int i = 0; i < n_vectors; ++i, p_vect++) {
        res = compute_asset_tag_from_entropy(p_vect->entropy, ACLASS_ASSET, asset_tag);
        TEST_ASSERT(res);
        TEST_ASSERT_EQUAL_MEMORY(p_vect->asset_tag, asset_tag, sizeof(asset_tag));
    }
}

void test_generate_asset_entropy(test_ctx_t *test_ctx) {
    int n_vectors = sizeof(asset_test_data) / sizeof(asset_test_data[0]);
    const asset_test_data_t *p_vect = asset_test_data;
    uint8_t entropy[SHA256_LEN] = {0};

    for (int i = 0; i < n_vectors; ++i, p_vect++) {
        bool res = generate_asset_entropy(p_vect->contract_hash,
                                          p_vect->prevout_txid,
                                          p_vect->prevout_index,
                                          entropy);
        TEST_ASSERT(res);
        TEST_ASSERT_EQUAL_MEMORY(p_vect->entropy, entropy, sizeof(entropy));
    }
}

void test_liquid_compute_asset_tag(test_ctx_t *test_ctx) {
    int n_vectors = sizeof(asset_test_data) / sizeof(asset_test_data[0]);
    const asset_test_data_t *p_vect = asset_test_data;
    uint8_t asset_tag[LIQUID_ASSET_TAG_LEN] = {0};

    for (int i = 0; i < n_vectors; ++i, p_vect++) {
        bool res = liquid_compute_asset_tag(p_vect->contract_hash,
                                            p_vect->prevout_txid,
                                            p_vect->prevout_index,
                                            p_vect->asset_class,
                                            asset_tag);
        TEST_ASSERT(res);
        TEST_ASSERT_EQUAL_MEMORY(p_vect->asset_tag, asset_tag, sizeof(asset_tag));
    }
}

void test_suite_liquid_assets(test_ctx_t *test_ctx) {
    RUN_TEST(test_sha256_midstate_reversed);
    RUN_TEST(test_compute_asset_tag_from_entropy);
    RUN_TEST(test_generate_asset_entropy);
    RUN_TEST(test_liquid_compute_asset_tag);
}
